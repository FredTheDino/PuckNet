Manifold :: blob {
    t: float,
    normal: (float, float),
    a: Circle | Wall,
    b: Circle | Wall,
}

Circle :: blob {
    rad: float,
    pos: (float, float),
}

Wall :: blob {
    normal: (float, float),
    pos: (float, float),
}

Body :: blob {
    pos: (float, float),
    vel: (float, float),
}

CircleBody :: blob {
    mass: float,
    rad: float,
    pos: (float, float),
    vel: (float, float),
}

// a  - a point on the first line
// b  - a point on the second line
// av - the direction the a-line is pointed
// Returns the time until it occurs - on no overlap the time is negative
line_vs_line :: fn a: (float, float), av: (float, float), b: (float, float), bv: (float, float) -> float {
    // TODO(ed): Normalize `av`
    top :: (b[0] - a[0]) * bv[1] - (b[1] - a[1]) * bv[0]
    bot :: av[0] * bv[1] - av[1] * bv[0]
    // NOTE(ed): This minus sign is here - I don't like it
    ret -1.0 if bot == 0.0 else top / bot
}

// Checks the collision - movement is the relative
// movement of the two objects seen from `a`.
circle_vs_wall :: fn c: Circle, w: Wall, movement: (float, float) -> Manifold {
    n :: w.normal if dot(w.normal, movement) < 0.0 else -w.normal

    a :: c.pos
    tan :: (w.normal[1], w.normal[0])

    b :: w.pos + c.rad * n
    t1 :: line_vs_line' a, movement, b, tan

    b :: w.pos - c.rad * n
    t2 :: line_vs_line' a, movement, b, tan

    t :: min(t1, t2) if > 0.0 else max(t1, t2)

    Manifold {
        t: t,
        normal: n,
        a: c,
        b: w,
    }
}

// Checks the collision - movement is the relative
// movement of the two objects seen from `a`.
circle_vs_circle :: fn a: Circle, b: Circle, movement: (float, float) -> Manifold {
    error :: Manifold{
        t: -1.0,
        normal: (0.0 , 0.0),
        a: a,
        b: b,
    }

    speed :: magnitude' movement
    if speed == 0.0 {
        ret error
    }

    movement_dir :: movement / speed
    distance :: b.pos - a.pos
    t_to_center :: dot' distance, movement_dir
    closest :: a.pos + t_to_center * movement_dir
    p_to_c_squared :: magnitude_squared' closest - b.pos
    discriminant :: pow(a.rad + b.rad, 2.0) - p_to_c_squared

    if discriminant < 0.0 {
        ret error
    }

    delta :: sqrt(discriminant)

    t := (t_to_center - delta) / speed
    if t < 0.0 || 1.0 < t {
        t = (t_to_center + delta) / speed
        if t < 0.0 || 1.0 < t {
            ret error
        }
    }

    n :: normalize' a.pos + t * movement - b.pos
    n :: n if dot(n, movement) < 0.0 else -n

    Manifold {
        t: t,
        normal : n,
        a: a,
        b: b,
    }
}
