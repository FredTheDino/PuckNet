Manifold :: blob {
    t: float,
    normal: (float, float),
}

Shape :: blob {
    pos: (float, float),
    rad: (float),
    line_check: fn (float, float), (float, float) -> bool,

    filter: void | fn (float, float), (float, float) -> bool,
}

Circle :: blob {
    pos: (float, float),
    rad: float,
}

Wall :: blob {
    normal: (float, float),
    dist: float,
}

// a  - a point on the first line
// b  - a point on the second line
// av - the direction the a-line is pointed
// Returns the time until it occurs - on no overlap the time is negative
line_vs_line :: fn a: (float, float), av: (float, float), b: (float, float), bv: (float, float) -> float {
    // TODO(ed): Normalize `av`
    top :: (b[0] - a[0]) * bv[1] - (b[1] - a[1]) * bv[0]
    bot :: av[0] * bv[1] - av[1] * bv[0]
    // NOTE(ed): This minus sign is here - I don't like it
    ret -1.0 if bot == 0.0 else top / bot
}

circle_vs_wall :: fn c: Circle, w: Wall, movement: (float, float) -> Manifold {
    a :: c.pos
    tan :: (w.normal[1], w.normal[0])
    b :: -(w.dist + c.rad) * w.normal
    near :: line_vs_line' a, movement, b, tan
    b :: -(w.dist - c.rad) * w.normal
    far  :: line_vs_line' a, movement, b, tan

    t := near
    if 0.0 < far || far < near {
        t = far
    }

    n := w.normal
    if dot(n, movement) < 0.0 {
        n = -n
    }

    Manifold {
        t: t,
        normal: n,
    }
}

normalize :: fn vec : ( float, float) -> (float, float) {
    if magnitude(vec) == 0.0{
        ret vec
    }

    ret vec / magnitude(vec)
}


cricle_vs_circle :: fn a: Circle, b: Circle, movement: (float, float) -> Manifold {
    ab :: b.pos - a.pos
    mov_norm :: normalize' movement
    s :: dot' ab, mov_norm
    c :: a.pos + s * mov_norm
    bc :: c - b.pos

    h :: magnitude' bc

    l2 :: pow((a.rad + b.rad), 2.0) - pow(h, 2.0)

    if l2 > 0.0 {
        l :: sqrt' l2

        near := magnitude(c) - l
        far := magnitude(c) + l

        t :: near if > 0.0 else far

        n :: normalize' a.pos - b.pos + t * mov_norm

        ret Manifold {
            t: t,
            normal : n,
        }
    }

    ret Manifold{
        t: -1.0,
        normal: (0.0 , 0.0),
    }
}
