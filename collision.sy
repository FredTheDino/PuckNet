Manifold :: blob {
    t: float,
    normal: (float, float),
    a: Circle | Wall,
    b: Circle | Wall,
}

Circle :: blob {
    rad: float,
    pos: (float, float),
}

Wall :: blob {
    normal: (float, float),
    pos: (float, float),
}

Body :: blob {
    pos: (float, float),
    vel: (float, float),
}

CircleBody :: blob {
    rad: float,
    pos: (float, float),
    vel: (float, float),
}

// a  - a point on the first line
// b  - a point on the second line
// av - the direction the a-line is pointed
// Returns the time until it occurs - on no overlap the time is negative
line_vs_line :: fn a: (float, float), av: (float, float), b: (float, float), bv: (float, float) -> float {
    // TODO(ed): Normalize `av`
    top :: (b[0] - a[0]) * bv[1] - (b[1] - a[1]) * bv[0]
    bot :: av[0] * bv[1] - av[1] * bv[0]
    // NOTE(ed): This minus sign is here - I don't like it
    ret -1.0 if bot == 0.0 else top / bot
}

// Checks the collision - movement is the relative
// movement of the two objects seen from `a`.
circle_vs_wall :: fn c: Circle, w: Wall, movement: (float, float) -> Manifold {
    n :: w.normal if dot(w.normal, movement) < 0.0 else -w.normal

    a :: c.pos
    tan :: (w.normal[1], w.normal[0])

    b :: w.pos + c.rad * n
    near :: line_vs_line' a, movement, b, tan

    b :: w.pos - c.rad * n
    far  :: line_vs_line' a, movement, b, tan

    t :: near if > 0.0 else far

    Manifold {
        t: t,
        normal: n,
        a: c,
        b: w,
    }
}

// Checks the collision - movement is the relative
// movement of the two objects seen from `a`.
circle_vs_circle :: fn a: Circle, b: Circle, movement: (float, float) -> Manifold {
    mov_norm :: normalize' movement
    s :: dot' b.pos - a.pos, mov_norm
    c :: a.pos + s * mov_norm
    h :: magnitude' c - b.pos

    l2 :: pow(a.rad + b.rad, 2.0) - pow(h, 2.0)

    if l2 < 0.0 {
        ret Manifold{
            t: -1.0,
            normal: (0.0 , 0.0),
            a: a,
            b: b,
        }
    }

    l :: sqrt' l2
    near := magnitude(c) - l
    far := magnitude(c) + l

    t :: near if > 0.0 else far
    n :: normalize' a.pos - b.pos + t * mov_norm

    Manifold {
        t: t,
        normal : n,
        a: a,
        b: b,
    }
}
