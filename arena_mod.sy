use assets
use collision
use game

Arena :: blob {
    draw: fn -> void,
    update: fn float -> void,
    walls: [collision.Wall],
    corners: [collision.Circle],
    goals: [collision.Circle],
}

Mupp :: blob {
    pos: (float, float),
    bobbiness: float,
    rgb: (float, float, float),
    sprite: int,
}

:Arena is :game.Entity


arena_new :: fn pos: (float, float) -> Arena {
    pos :: (0.0, 0.0)
    scale :: 2.0

    muppets:[Mupp]: []
    place_mupps :: fn lo_x: float, hi_x: float, lo_y: float, hi_y: float {
        y := hi_y
        loop y > lo_y {
            x := lo_x
            loop x < hi_x {
                muppets -> push' Mupp {
                    pos: (x + 0.5 * rem(y, 2.0), y) + (l_random_range(-0.5, 0.5), l_random_range(-0.5, 0.5)),
                    bobbiness: l_random_range(0.1, 0.5),
                    rgb: (l_random_range(0.2, 0.4), l_random_range(0.2, 0.4), l_random_range(0.2, 0.4)),
                    sprite: l_random_range(0, 3),
                }
                x += 1.0
            }
            y -= 1.0
        }
    }

    place_mupps(-45.5, -26.0, -20.0, 20.0)
    place_mupps( 26.0, 45.5, -20.0, 20.0)
    place_mupps( -26.0, 26.0, -20.0, -13.0)

    r :: scale / 5.0
    x :: 0.80 * scale
    y :: 0.30 * scale

    self: !Arena = nil
    self = Arena{
        draw: fn -> void {
            gray :: (0.2, 0.2, 0.2)
            l_gfx_rect' (0.0, 0.0), (20.0, 20.0), gray

            t :: rem' 0.1 * l_time(), 4.0 * scale

            l_gfx_sprite' assets.ads, (0, 0), pos + (t, (scale - 0.2) / 1.5), (4.0, 4.0 * 20.0 / 401.0) * scale
            l_gfx_sprite' assets.ads, (0, 0), pos + (t - 4.0 * scale, (scale - 0.2) / 1.5), (4.0, 4.0 * 20.0 / 401.0) * scale

            l_gfx_sprite' assets.ads, (0, 0), pos + (t - 4.0 * scale, (scale - 0.2) / 1.5), (4.0, 4.0 * 20.0 / 401.0) * scale

            l_gfx_rect' -scale * 1.3, 0.0, scale, 3.0, gray
            l_gfx_rect' scale * 1.3, 0.0, scale, 3.0, gray

            l_gfx_sprite' assets.arena, (0, 0), pos, (2.0, 1.0) * scale
            l_gfx_sprite' assets.border, (0, 0), pos + (0.0, scale / 2.0), (2.0, 2.0 * 40.0 / 200.0) * scale
            // TODO(ed): Move this to a custom file - it needs to be
            // rendered on top of the player
            t :: l_time'
            exitement :: sin(t)
            muppets -> for_each' fn m: Mupp {
                mupp :: assets.mupps[m.sprite]
                scale :: as_float(mupp[1][1]) / as_float(mupp[1][0])
                uni_scale :: 0.1
                l_gfx_sprite(mupp[0], (0, 0), 0.08 * m.pos + 0.1 * (0.0, sin((t + 100.0) * exitement * exitement * m.bobbiness)) * m.bobbiness, (uni_scale) * (1.0, scale), m.rgb)
            }
        },
        update: fn delta: float {
        },
        walls: [
            collision.Wall{ normal: (0.0, -1.0), pos: (0.0,  scale / 2.0) },
            collision.Wall{ normal: (0.0,  1.0), pos: (0.0, -scale / 2.0) },
            collision.Wall{ normal: (-1.0, 0.0), pos: ( scale,       0.0) },
            collision.Wall{ normal: ( 1.0, 0.0), pos: (-scale,       0.0) },
        ],
        corners: [
            // Radius is negative because of collisions inside of the circle
            collision.Circle { rad: -r, pos: (-x,  y) },
            collision.Circle { rad: -r, pos: (-x, -y) },
            collision.Circle { rad: -r, pos: ( x, -y) },
            collision.Circle { rad: -r, pos: ( x,  y) },
        ],
        goals: [
            collision.Circle { rad: scale / 11.0, pos: (x, y) *  0.85 },
            collision.Circle { rad: scale / 11.0, pos: (x, y) * -0.85 },
        ],
    }

    ret self
}
