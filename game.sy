Entity :: blob {
    draw: fn -> void,
    update: fn float -> void,
}

Player :: blob {
    pos: (float, float),
    vel: (float, float),
    acc: (float, float),
    draw: fn -> void,
    update: fn float -> void,
}

player_new :: fn pos: (float, float) -> Player {
    self: !Player = nil
    self = Player{
        pos: pos,
        vel: (0.0, 0.0),
        acc: (0.0, 0.0),
        draw: fn -> void {
            rgb :: (sin(l_time()), cos(l_time()), 1.0)
            l_gfx_rect' self.pos, (0.1, 0.1), rgb
        },
        update: fn delta: float -> void {
            input := (
                (l_input_value("right") - l_input_value("left")),
                (l_input_value("up") - l_input_value("down")),
            )
            force :: 10.0
            self.acc = input * force
            self.vel += self.acc * delta

            // Air resistance
            self.vel *= pow' 0.50, delta

            // Friction
            speed :: magnitude' self.vel
            moving_fric :: 0.8 * delta
            if speed <= moving_fric {
                self.vel = (0.0, 0.0)
            } else {
                self.vel -= (self.vel / speed) * moving_fric
            }

            self.pos += self.vel * delta
        }
    }
    ret self
}

:Player is :Entity

entities : [Entity] = []

init :: fn {
    l_bind_key("w", "up")
    l_bind_key("a", "left")
    l_bind_key("s", "down")
    l_bind_key("d", "right")

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")

    push' entities, player_new' (0.0, 0.0)
}

update :: fn delta: float -> void {
    entities -> for_each' fn e: Entity {
        e.update' delta
    }
}

draw :: fn {
    entities -> for_each' fn e: Entity {
        e.draw'
    }
}

start :: fn {
    // Added for safety - to avoid delta=0
    l_update'

    init'
    loop !l_input_down("quit") {
        l_update'
        l_render'
        update' l_delta'
        draw'
    }
}

