clamp :: fn v: float, lo: float, hi: float -> float {
    min' hi, max' lo, v
}

angle_distance :: fn a: float, b: float -> float {
    rem(3.14 + b - a, 2.0 * 3.14) - 3.14
}

friction :: fn v: float, f: float -> float {
    if abs(v) <= f {
        ret 0.0
    } else {
        ret v - sign(v) * f
    }
}

Entity :: blob {
    draw: fn -> void,
    update: fn float -> void,
}

Player :: blob {
    pos: (float, float),
    rot: float,
    vel: float,
    acc: float,
    tackle_timer: float,
    draw: fn -> void,
    update: fn float -> void,
}

player_new :: fn pos: (float, float) -> Player {
    self: !Player = nil
    self = Player{
        pos: pos,
        rot: 0.0,
        vel: 0.0,
        acc: 0.0,
        tackle_timer: 0.0,

        draw: fn -> void {
            rgb :: (sin(l_time()), cos(l_time()), 1.0)
            l_gfx_rect' self.pos, (0.1, 0.1), self.rot, rgb
        },
        update: fn delta: float -> void {
            self.tackle_timer = max' 0.0, self.tackle_timer - delta

            direction := (l_input_value("left") - l_input_value("right"),
                          l_input_value("up")   - l_input_value("down"))

            if self.tackle_timer == 0.0 && l_input_pressed("tackle") {
                self.tackle_timer = 1.0
                self.vel += 2.0
            }

            if self.tackle_timer > 0.5 {
                direction = (0.0, 0.0)
            }

            input := magnitude' direction

            // Linear motion
            force :: 3.0
            self.acc = input * force
            self.vel += self.acc * delta

            // Air resistance
            air_fric :: 0.20 - self.tackle_timer * 0.1
            self.vel *= pow' air_fric, delta

            // Friction
            ice_fric :: 0.8
            self.vel = friction' self.vel, ice_fric * delta

            break_fric :: 5.0
            if l_input_down("break") {
                self.vel = friction' self.vel, break_fric * delta
            }

            self.pos += (cos(self.rot), sin(self.rot)) * self.vel * delta

            // Rotation
            max_rotation :: 4.0 + 6.0 / (2.0 * input + 0.1) // rad/sec
            rotation_speed :: 2.0 * 3.14

            direction_angle :: angle(direction) if direction != (0.0, 0.0) else self.rot
            delta_angle :: angle_distance' self.rot, direction_angle
            rotation :: clamp' delta_angle * rotation_speed, -max_rotation, max_rotation
            self.rot += rotation * delta
        }
    }
    ret self
}

:Player is :Entity

entities : [Entity] = []

init :: fn {
    l_bind_key("w", "up")
    l_bind_key("a", "left")
    l_bind_key("s", "down")
    l_bind_key("d", "right")
    l_bind_key("SPACE", "break")
    l_bind_key("e", "tackle")

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")

    push' entities, player_new' (0.0, 0.0)
}

update :: fn delta: float -> void {
    entities -> for_each' fn e: Entity {
        e.update' delta
    }
}

draw :: fn {
    entities -> for_each' fn e: Entity {
        e.draw'
    }
}

start :: fn {
    // Added for safety - to avoid delta=0
    l_update'

    init'
    loop !l_input_down("quit") {
        l_update'
        l_render'
        update' l_delta'
        draw'
    }
}

