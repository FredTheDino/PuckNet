use collision

clamp :: fn v: float, lo: float, hi: float -> float {
    min' hi, max' lo, v
}

angle_distance :: fn a: float, b: float -> float {
    angle' (-cos(b - a), sin(b - a))
}

friction :: fn v: float, f: float -> float {
    if abs(v) <= f {
        ret 0.0
    } else {
        ret v - sign(v) * f
    }
}

reflect :: fn v: (float, float), n: (float, float) -> (float, float){
    v - 2.0 * n * dot' v, n
}

Entity :: blob {
    draw: fn -> void,
    update: fn float -> void,
}

Input :: blob {
    dir: (float, float),
    brake: bool,
    tackle: bool,
    shoot: bool,
}

Player :: blob {
    pos: (float, float),
    rot: float,
    vel: float,
    acc: float,
    puck: Puck?,
    try_grab: fn Puck -> void,
    tackle_timer: float,
    draw: fn -> void,
    process_input: fn Input, float -> void,
    update: fn float -> void,
}

player_new :: fn pos: (float, float) -> Player {
    self: !Player = nil
    self = Player{
        pos: pos,
        rot: 0.0,
        vel: 0.0,
        acc: 0.0,
        puck: nil,
        try_grab: fn puck: Puck -> void {
            if (magnitude(self.pos - puck.pos) < 0.05
                && !puck.held
                && puck.hold_cooldown == 0.0) {
                self.puck = puck
                puck.held = true
            }
        },
        tackle_timer: 0.0,
        draw: fn -> void {
            rgb :: (sin(l_time()), cos(l_time()), 1.0)
            l_gfx_rect' self.pos, (0.1, 0.1), self.rot, rgb
        },
        process_input: fn input: Input, delta: float -> void {

            shoot_speed :: self.vel + 2.0

            if input.shoot && self.puck is :Puck {
                puck: !Puck = self.puck
                puck.vel = (cos(self.rot), sin(self.rot)) * shoot_speed
                puck.held = false
                puck.hold_cooldown = 0.1
                self.puck = nil
            }

            if self.tackle_timer == 0.0 && input.tackle {
                self.tackle_timer = 1.0
                self.vel += 2.0
            }

            if self.tackle_timer > 0.5 {
                input.dir = (0.0, 0.0)
            }

            force :: 3.0
            self.acc += force * magnitude' input.dir

            break_fric :: 5.0
            if input.brake {
                self.vel = friction' self.vel, break_fric * delta
            }

            // Rotation
            max_rotation :: 4.0 + 6.0 / (2.0 * magnitude(input.dir) + 0.1) // rad/sec
            rotation_speed :: 2.0 * 3.14

            direction_angle :: angle(input.dir) if input.dir != (0.0, 0.0) else self.rot
            delta_angle :: angle_distance' self.rot, direction_angle
            rotation :: clamp' delta_angle * rotation_speed, -max_rotation, max_rotation
            self.rot += rotation * delta
        },
        update: fn delta: float -> void {
            self.tackle_timer = max' 0.0, self.tackle_timer - delta

            // Linear motion
            self.vel += self.acc * delta
            self.acc = 0.0

            // Air resistance
            air_fric :: 0.20 - self.tackle_timer * 0.1
            self.vel *= pow' air_fric, delta

            // Friction
            ice_fric :: 0.8
            self.vel = friction' self.vel, ice_fric * delta

            self.pos += (cos(self.rot), sin(self.rot)) * self.vel * delta

            // Puck
            if self.puck is :Puck {
                puck: !Puck = self.puck
                puck.pos = self.pos
                puck.vel = (0.0, 0.0)
            }
        }
    }
    ret self
}

:Player is :Entity

Puck :: blob {
    pos: (float, float),
    vel: (float, float),
    held: bool,
    hold_cooldown: float,
    draw: fn -> void,
    process_input: fn Input, float -> void,
    update: fn float -> void,
}

puck_new :: fn pos: (float, float) -> Puck {
    self: !Puck = nil
    self = Puck{
        pos: pos,
        vel: (0.0, 0.0),
        held: false,
        hold_cooldown: 0.0,
        draw: fn -> void {
            rgb :: (1.0, 1.0, 1.0)
            l_gfx_rect' self.pos, (0.04, 0.04), 0.0, rgb
            l_gfx_rect' self.pos, (0.04, 0.04), 0.0 + 3.14 / 3.0, rgb
            l_gfx_rect' self.pos, (0.04, 0.04), 0.0 + 3.14 * 2.0 / 3.0, rgb
        },
        process_input: fn input: Input, delta: float -> void {
        },
        update: fn delta: float -> void {
            // Pickup cooldown
            self.hold_cooldown = max' self.hold_cooldown - delta, 0.0

            // Air resistance
            //air_fric :: 0.20
            //self.vel *= pow' air_fric, delta

            // Friction
            ice_fric :: 1.0
            speed :: magnitude' self.vel
            self.vel = collision.normalize(self.vel) * friction' speed, ice_fric * delta

            wall :: collision.Wall {
                normal : (-1.0, 0.0),
                dist : 1.0,
            }

            circle :: collision.Circle {
                pos : self.pos,
                rad : 0.1,
            }

            vel :: self.vel * delta
            coll :: collision.circle_vs_wall' circle, wall, vel
            
            if 0.0 < coll.t && coll.t < 1.0 {
                self.pos += vel * coll.t
                self.vel = reflect' self.vel, coll.normal
                self.pos += self.vel * (1.0 - coll.t) * delta

            }
            else{
                self.pos += vel

            }

        }
    }
    ret self
}

:Puck is :Entity

players : [Player] = []
entities : [Entity] = []
puck : Puck = puck_new' (0.0, 0.0)

init :: fn {
    l_bind_key("w", "up")
    l_bind_key("a", "left")
    l_bind_key("s", "down")
    l_bind_key("d", "right")
    l_bind_key("SPACE", "brake")
    l_bind_key("e", "tackle")
    l_bind_key("q", "swap_player")
    l_bind_key("f", "shoot")

    l_bind_axis(0, "LEFTX", "right")
    l_bind_axis(0, "LEFTY", "down")
    l_bind_button(0, "A", "brake")
    l_bind_button(0, "B", "tackle")
    l_bind_button(0, "LEFTSHOULDER", "swap_player")

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")

    player := player_new' (0.0, 0.0)
    push' players, player
    push' entities, player

    player.puck = puck

    player := player_new' (1.0, 0.0)
    push' players, player
    push' entities, player

    push' entities, puck
}

current_player := 0
update :: fn delta: float -> void {
    input :: Input {
        // TODO: Normalize this
        dir: (l_input_value("left") - l_input_value("right"),
              l_input_value("up")   - l_input_value("down")),

        brake: l_input_down("brake"),
        tackle: l_input_pressed("tackle"),
        shoot: l_input_pressed("shoot"),
    }
    if l_input_pressed("swap_player") {
        current_player += 1
        current_player = rem' current_player, len' players
    }
    players[current_player].process_input' input, delta
    puck.process_input' input, delta

    players -> for_each' fn p: Player {
        p.try_grab' puck
    }

    entities -> for_each' fn e: Entity {
        e.update' delta
    }
}

draw :: fn {
    entities -> for_each' fn e: Entity {
        e.draw'
    }
}

start :: fn {
    // Added for safety - to avoid delta=0
    l_update'

    a :: collision.Circle {
        pos: (0.0, 0.0),
        rad: 1.0,
    }

    b :: collision.Circle {
        pos: (6.0, 4.0),
        rad: 1.0
    }

    m :: collision.cricle_vs_circle' a, b, (1.0, 1.0)
    print "T"
    print m.t
    print "Normal"
    print m.normal
    init'
    loop !l_input_down("quit") {
        l_update'
        l_render'
        update' l_delta'
        draw'
    }
}

