use arena_mod
use assets
use browser
use client
use collision
use entity
use menu
use mupps
use particles
use practice
use server
use text
use tick
use util

Game :: blob {
    puck: entity.Puck,
    players: {int: entity.Player},
    entities: [entity.Entity],
    bodies: [collision.CircleBody],
    arena: arena_mod.Arena,
    score: (int, int),
    player_id: int,
    next_id: int,
    update: fn float -> void,
    draw: fn -> void,
    process_input: fn -> void,
}

new_game :: fn -> Game {
    puck := entity.puck_new' (0.0, 0.0)
    self : !Game = nil
    self = Game {
        puck: puck,
        players: [],
        entities: [puck],
        bodies: [puck],
        arena: arena_mod.arena_new((0.0, 0.0)),
        score: (0, 0),
        player_id: -1,
        next_id: 0,
        update: fn delta: float {
            self.players -> for_each' fn p: entity.Player {
                p.try_grab' puck
            }

            collision_check' delta, self

            self.entities -> for_each' fn e: entity.Entity {
                e.update' delta
            }

            particles.update' delta
        },
        draw: fn {
            self.arena.draw'
            particles.render'

            self.entities -> for_each' fn e: entity.Entity {
                if !(e is :entity.Puck) {
                    e.draw'
                }
            }

            self.entities -> for_each' fn e: entity.Entity {
                if e is :entity.Puck {
                    p: !entity.Puck = e

                    // Make things exiting
                    exitement_change :: magnitude_squared(p.vel)
                    mupps.add_exitement' exitement_change * l_delta() * 1.0

                    // The holder will draw the puck in the right place if there is one
                    if p.holder is :void {
                        e.draw'
                    }
                }
            }

            mupps.draw'

            zero :: as_chars("0")[0]
            text.draw_char' -0.1, 0.9, 1., self.score[0] + zero, (255., 0., 0., 255.) / 255.
            text.draw_char' 0.1,  0.9, 1., self.score[1] + zero, (30., 194., 58., 255.) / 255.
        },
        process_input: fn {
            delta := l_delta'

            self.players -> for_each' fn player: entity.Player {
                player.remove = entity.player.last_seen >= 3.0
            }
            self.players = self.players -> filter' fn _id: int, player: entity.Player -> bool {
                !player.remove
            }
            self.entities = self.entities -> filter' fn entity: entity.Entity -> bool {
                !entity.remove
            }

            self.players -> for_each' fn p: entity.Player {
                p.process_input' delta
                if p.input is :entity.Input {
                    input: !entity.Input = p.input
                    p.input = clear_input(input)
                }
            }
        }
    }
    ret self
}

State :: blob {
    name: str,
    update: fn float -> void,
    draw: fn -> void,
    process_input: fn -> void,
}

GameState :: blob {
    game: Game,
    name: str,
    update: fn float -> void,
    draw: fn -> void,
    process_input: fn -> void,
}

:GameState is :State

states : [State] = []

main_menu_lines := [
    "Connect",
    "Practice",
    "Start server",
    "Settings",
    "Credits",
    "Quit",
]
main_menu : menu.Menu = menu.menu_new' main_menu_lines

bind_keys :: fn {
    l_bind_key("w", "up")
    l_bind_key("a", "left")
    l_bind_key("s", "down")
    l_bind_key("d", "right")
    l_bind_key("SPACE", "shoot")

    l_bind_key("Up", "up")
    l_bind_key("Left", "left")
    l_bind_key("Down", "down")
    l_bind_key("Right", "right")
    l_bind_key("Return", "shoot")

    l_bind_axis(0, "LEFTX", "right")
    l_bind_axis(0, "LEFTY", "down")
    l_bind_button(0, "A", "shoot")

    l_bind_button(0, "dpup", "up")
    l_bind_button(0, "dpdown", "down")
    l_bind_button(0, "dpleft", "left")
    l_bind_button(0, "dpright", "right")

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")
}

init :: fn {
    mupps.init'
    particles.init'
    assets.load_assets'
    states -> push' menu_state
}

player_join :: fn {
    state := last(states)
    if :GameState is state {
        state : !GameState = state
        game := state.game

        id := game.next_id
        game.next_id += 1

        ip := n_rpc_current_request_ip'
        n_rpc_client_ip' ip, assign_player_id, id

        //TODO(gu): Team balancing?
        team :: rem(id, 2)
        player_pos := (as_float(team) + l_random_range(-1.0, 0.0), l_random_range(-0.5, 0.5))
        player := entity.player_new' player_pos, team, id
        game.players[id] = player
        push' game.entities, player
        push' game.bodies, player
    }
}

assign_player_id :: fn id: int {
    state := last(states)
    if :GameState is state {
        state : !GameState = state
        game := state.game

        game.player_id = id
    }
}

poll_input :: fn -> entity.Input {
    entity.Input {
        dir: normalize((l_input_value("right") - l_input_value("left"),
                        l_input_value("up")    - l_input_value("down"))),

        tackle: l_input_pressed("shoot"),
        charge: l_input_down("shoot"),
        shoot: l_input_released("shoot"),

        select: l_input_pressed("shoot"),

        player: nil,
    }
}

set_input :: fn input: entity.Input {
    state := last(states)
    if state is :GameState {
        state : !GameState = state
        game := state.game

        player := game.players[input.player]
        player.last_seen = 0.0
        if player.input is nil {
            player.input = input
        } else {
            player_input: !entity.Input = player.input
            player.input = merge_inputs(player_input, input)
        }
    }
}

merge_inputs :: fn current: entity.Input, new: entity.Input -> entity.Input {
    entity.Input {
        dir: new.dir,
        charge: current.charge || new.charge,
        tackle: current.tackle || new.tackle,
        shoot: current.shoot || new.shoot,
        select: current.select || new.select,
        player: new.player,
    }
}

clear_input :: fn input: entity.Input -> entity.Input {
    entity.Input {
        dir: input.dir,
        charge: false,
        tackle: false,
        shoot: false,
        select: false,
        player: input.player,
    }
}

collision_check :: fn delta:float, game: Game {
    // Find next collision
    a_i := 0
    // TODO(ed): Write this with for_each, when the upvalue bug is fixed.
    loop a_i < len(game.bodies) {
        a := game.bodies[a_i]
        b_i := -1
        game.bodies -> for_each' fn b: collision.CircleBody {
            b_i += 1
            // Skip the ones we've seen
            if a_i >= b_i {
                ret
            }
            if :entity.Puck is a || :entity.Puck is b {
                ret
            }
            col :: collision.circle_vs_circle' a, b
            if col.depth <= 0.0 {
                ret
            }
            collision.solve' col
        }
        game.arena.walls -> for_each' fn w: collision.Wall {
            col :: collision.circle_vs_wall' a, w
            if col.depth <= 0.0 {
                ret
            }
            collision.solve' col
        }
        game.arena.corners -> for_each' fn c: collision.Circle {
            col := collision.circle_vs_in_circle' a, c
            if col.depth <= 0.0 {
                ret
            }
            if (sign(col.normal[1]) == sign(c.pos[1])
                || sign(col.normal[0]) == sign(c.pos[0])
                || magnitude_squared(a.pos) < magnitude_squared(c.pos)) {
                ret
            }
            collision.solve' col
        }
        // Goal outside collision
        game.arena.goals -> for_each' fn g: arena_mod.Goal {
            col := collision.circle_vs_circle' a, g.cage
            if col.depth <= 0.0 {
                ret
            }
            if abs(a.pos[0]) > abs(g.cage.pos[0]) || sign(col.normal[0]) == sign(g.cage.pos[0]) {
                w :: collision.Wall {
                    normal: (sign(g.cage.pos[0]), 0.0),
                    pos: g.cage.pos,
                }
                in_col := collision.circle_vs_wall' a, w
                if in_col.depth <= 0.0 {
                    ret
                }
                if :entity.Puck is a && dot(a.vel, in_col.normal) < 0.0 && col.depth > 0.03 {
                    particles.goal' a.pos
                    n_rpc_clients' particles.goal, a.pos
                    game.score += (0 if game.puck.pos[0] < 0. else 1, 1 if game.puck.pos[0] < 0. else 0)
                    game.puck.vel *= 0.0
                    game.puck.pos *= 0.0
                    if :entity.Player is game.puck.holder {
                        holder: !entity.Player = game.puck.holder
                        holder.puck = nil
                    }
                    assets.random_cheer()
                    game.puck.holder = nil
                }
                collision.solve' in_col
            } else {
                if col.depth <= 0.0 {
                    ret
                }
                collision.solve' col
            }
        }
        a_i += 1
    }

    game.bodies -> for_each' fn c: collision.Body {
        c.pos += c.vel * delta
    }
    game.arena.update' delta
}

menu_state :: State {
    name: "menu",
    update: fn delta: float -> void {
        main_menu.update' delta
        if main_menu.line_selected {
            if main_menu_lines[main_menu.line_index] == "Connect" {
                // When we break out of the client loop, return here.
                states -> push' browser_state
            } else if main_menu_lines[main_menu.line_index] == "Start server" {
                states -> push' server.new_server_state'
            } else if main_menu_lines[main_menu.line_index] == "Practice" {
                states -> push' practice.new_practice_state'
            } else {
                print "Unhandled main menu item:"
                print main_menu_lines[main_menu.line_index]
            }
        }
    },
    draw: main_menu.draw,
    process_input: fn {
        main_menu.process_input' menu.from_input' poll_input'
    }
}

browser_menu := menu.menu_new' []

browser_state :: State {
    name: "Server browser",
    update: fn delta: float -> void {
        browser_menu.lines = browser.servers -> map' fn server: browser.Server -> str {
            as_str(server.online) + ": " + server.name
        }
    },
    draw: fn -> void {
        browser_menu.draw'
    },
    process_input: fn {
        browser_menu.process_input' menu.from_input' poll_input'

        if browser_menu.line_selected {
            // Disconnect from the server browser
            n_rpc_disconnect'

            // Connect to the selected server
            ip := browser.servers[browser_menu.line_index].join_ip
            states -> push' client.new_client_state' ip
            //TODO(gu): show connection error in ui in some way
        }
    }
}

update :: fn delta: float -> void {
    state := last(states)
    if :State is state {
        state : !State = state
        state.update' delta
    }

    // Logic for moving "out" of the program
    if l_input_pressed("quit") {
        states -> pop'
    }
}

set_entities :: fn incoming_entities: [entity.Entity], incoming_players: {int: entity.Player}, incomming_arena: arena_mod.Arena, incoming_score: (int, int) {
    state := last(states)
    if :GameState is state {
        state : !GameState = state
        game := state.game

        game.entities = incoming_entities
        game.players = incoming_players
        game.arena = incomming_arena
        game.score = incoming_score
    }
}

move_camera :: fn game: Game {
    x :: -game.players[game.player_id].pos[0]
    curr_x :: l_gfx_camera_at()[0]
    speed :: min' 1.0, 4.0 * l_delta'
    x :: x * speed + curr_x * (1.0 - speed)
    l_gfx_camera_place' x, 0.0
    l_gfx_camera_set_zoom' 0.7
}

reset_camera :: fn {
    l_gfx_camera_place' 0.0, 0.0
    l_gfx_camera_set_zoom' 1.0
}

draw :: fn {
    state := last(states)
    if :State is state {
        state : !State = state
        state.draw'
    }
}

process_input :: fn {
    state := last(states)
    if :State is state {
        state : !State = state
        state.process_input'
    }
}

start :: fn {
    if "browser" in args() {
        browser.start'
    } else {
        // We set window size before ANY call to the engine so we have the correct size from the beginning
        l_set_window_size' (800, 800)
        init'

        n_rpc_connect' "fuffens.xyz", 8388

        // Added for safety - to avoid delta=0
        l_update'

        bind_keys'
        loop len(states) > 0 {
            n_rpc_resolve'

            l_update'
            l_render'

            update' l_delta'
            draw'
            process_input'
        }
    }
}
