use arena_mod
use assets
use browser
use client
use collision
use config
use credits
use entity
use menu
use mupps
use particles
use practice
use server
use text
use tick
use util

PLAYER_DISCONNECT_TIMEOUT :: 3.0

Game :: blob {
    puck: entity.Puck,
    players: {int: entity.Player},
    entities: [entity.Entity],
    bodies: [collision.CircleBody],
    arena: arena_mod.Arena,
    score: (int, int),
    player_id: int,
    next_id: int,
    update: fn float -> void,
    draw: fn -> void,
    process_input: fn -> void,
}

new_game :: fn -> Game {
    puck := entity.puck_new' (0.0, 0.0)
    self : !Game = nil
    self = Game {
        puck: puck,
        players: {:},
        entities: [puck],
        bodies: [puck],
        arena: arena_mod.arena_new((0.0, 0.0)),
        score: (0, 0),
        player_id: -1,
        next_id: 0,
        update: fn delta: float {
            self.players -> for_each' fn _id: int, p: entity.Player {
                p.try_grab' puck
            }

            collision_check' delta, self

            self.entities -> for_each' fn e: entity.Entity {
                e.update' delta
            }

            particles.update' delta
        },
        draw: fn {
            self.arena.draw'
            particles.render'

            self.entities -> for_each' fn e: entity.Entity {
                if !(e is :entity.Puck) {
                    e.draw'
                }
            }

            self.entities -> for_each' fn e: entity.Entity {
                if e is :entity.Puck {
                    p: !entity.Puck = e

                    // Make things exiting
                    exitement_change :: magnitude_squared(p.vel)
                    mupps.add_exitement' exitement_change * l_delta() * 1.0

                    // The holder will draw the puck in the right place if there is one
                    if p.holder is :void {
                        e.draw'
                    }
                }
            }

            mupps.draw'

            zero :: as_chars("0")[0]
            text.draw_char' -0.1, 0.9, 1., self.score[0] + zero, (255., 0., 0., 255.) / 255.
            text.draw_char' 0.1,  0.9, 1., self.score[1] + zero, (30., 194., 58., 255.) / 255.
        },
        process_input: fn {
            delta := l_delta'

            self.players -> for_each' fn _id: int, player: entity.Player {
                player.remove = entity.player.last_seen >= PLAYER_DISCONNECT_TIMEOUT
            }
            self.players = self.players -> filter' fn _id: int, player: entity.Player -> bool {
                !player.remove
            }
            self.entities = self.entities -> filter' fn entity: entity.Entity -> bool {
                !entity.remove
            }

            self.players -> for_each' fn _id: int, p: entity.Player {
                p.process_input' delta
                if p.input is :entity.Input {
                    input: !entity.Input = p.input
                    p.input = clear_input(input)
                }
            }
        }
    }
    ret self
}

State :: blob {
    name: str,
    update: fn float -> void,
    draw: fn -> void,
    process_input: fn -> void,
    cleanup: fn -> void,
}

GameState :: blob {
    game: Game,
    name: str,
    update: fn float -> void,
    draw: fn -> void,
    process_input: fn -> void,
    cleanup: fn -> void,
}

:GameState is :State

states : [State] = []

main_menu_lines := [
    "Connect",
    "Practice",
    "Start Server",
    "Settings",
    "Credits",
    "Quit",
]
main_menu : menu.Menu = menu.menu_new' main_menu_lines, "PuckNet"

bind_keys :: fn {
    l_bind_key("w", "up")
    l_bind_key("a", "left")
    l_bind_key("s", "down")
    l_bind_key("d", "right")
    l_bind_key("SPACE", "shoot")

    l_bind_key("Up", "up")
    l_bind_key("Left", "left")
    l_bind_key("Down", "down")
    l_bind_key("Right", "right")
    l_bind_key("Return", "shoot")

    l_bind_axis(0, "LEFTX", "right")
    l_bind_axis(0, "LEFTY", "down")
    l_bind_button(0, "A", "shoot")

    l_bind_button(0, "dpup", "up")
    l_bind_button(0, "dpdown", "down")
    l_bind_button(0, "dpleft", "left")
    l_bind_button(0, "dpright", "right")
    l_bind_button(0, "start", "quit")

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")
}

init :: fn {
    mupps.init'
    particles.init'
    assets.load_assets'
    states -> push' menu_state
}

player_join :: fn {
    state := last(states)
    if :GameState is state {
        state : !GameState = state
        game := state.game

        id := game.next_id
        game.next_id += 1

        ip := n_rpc_current_request_ip'
        n_rpc_client_ip' ip, assign_player_id, id

        //TODO(gu): Team balancing?
        team :: rem(id, 2)
        player_pos := (as_float(team) + l_random_range(-1.0, 0.0), l_random_range(-0.5, 0.5))
        player := entity.player_new' player_pos, team, id
        game.players[id] = player
        push' game.entities, player
        push' game.bodies, player
    }
}

assign_player_id :: fn id: int {
    state := last(states)
    if :GameState is state {
        state : !GameState = state
        game := state.game

        game.player_id = id
    }
}

poll_input :: fn -> entity.Input {
    entity.Input {
        dir: normalize((l_input_value("right") - l_input_value("left"),
                        l_input_value("up")    - l_input_value("down"))),

        tackle: l_input_pressed("shoot"),
        charge: l_input_down("shoot"),
        shoot: l_input_released("shoot"),

        select: l_input_pressed("shoot"),

        player: nil,
    }
}

set_input :: fn input: entity.Input {
    state := last(states)
    if state is :GameState {
        state : !GameState = state
        game := state.game

        // Without the ID we don't know which player to set the input to.
        if input.player is nil {
            ret
        }
        id: !int = input.player

        player := game.players[id]
        if :entity.Player is player {
            player: !entity.Player = player
            player.last_seen = 0.0
            if player.input is nil {
                player.input = input
            } else {
                player_input: !entity.Input = player.input
                player.input = merge_inputs(player_input, input)
            }
        }
    }
}

merge_inputs :: fn current: entity.Input, new: entity.Input -> entity.Input {
    entity.Input {
        dir: new.dir,
        charge: current.charge || new.charge,
        tackle: current.tackle || new.tackle,
        shoot: current.shoot || new.shoot,
        select: current.select || new.select,
        player: new.player,
    }
}

clear_input :: fn input: entity.Input -> entity.Input {
    entity.Input {
        dir: input.dir,
        charge: false,
        tackle: false,
        shoot: false,
        select: false,
        player: input.player,
    }
}

collision_check :: fn delta:float, game: Game {
    // Find next collision
    a_i := 0
    // TODO(ed): Write this with for_each, when the upvalue bug is fixed.
    loop a_i < len(game.bodies) {
        a := game.bodies[a_i]
        b_i := -1
        game.bodies -> for_each' fn b: collision.CircleBody {
            b_i += 1
            // Skip the ones we've seen
            if a_i >= b_i {
                ret
            }
            if :entity.Puck is a || :entity.Puck is b {
                ret
            }
            col :: collision.circle_vs_circle' a, b
            if col.depth <= 0.0 {
                ret
            }
            collision.solve' col
        }
        game.arena.walls -> for_each' fn w: collision.Wall {
            col :: collision.circle_vs_wall' a, w
            if col.depth <= 0.0 {
                ret
            }
            collision.solve' col
        }
        game.arena.corners -> for_each' fn c: collision.Circle {
            col := collision.circle_vs_in_circle' a, c
            if col.depth <= 0.0 {
                ret
            }
            if (sign(col.normal[1]) == sign(c.pos[1])
                || sign(col.normal[0]) == sign(c.pos[0])
                || magnitude_squared(a.pos) < magnitude_squared(c.pos)) {
                ret
            }
            collision.solve' col
        }
        // Goal outside collision
        game.arena.goals -> for_each' fn g: arena_mod.Goal {
            col := collision.circle_vs_circle' a, g.cage
            if col.depth <= 0.0 {
                ret
            }
            if abs(a.pos[0]) > abs(g.cage.pos[0]) || sign(col.normal[0]) == sign(g.cage.pos[0]) {
                w :: collision.Wall {
                    normal: (sign(g.cage.pos[0]), 0.0),
                    pos: g.cage.pos,
                }
                in_col := collision.circle_vs_wall' a, w
                if in_col.depth <= 0.0 {
                    ret
                }
                if :entity.Puck is a && dot(a.vel, in_col.normal) < 0.0 && col.depth > 0.03 {
                    particles.goal' a.pos
                    n_rpc_clients' particles.goal, a.pos
                    game.score += (0 if game.puck.pos[0] < 0. else 1, 1 if game.puck.pos[0] < 0. else 0)
                    game.puck.vel *= 0.0
                    game.puck.pos *= 0.0
                    if :entity.Player is game.puck.holder {
                        holder: !entity.Player = game.puck.holder
                        holder.puck = nil
                    }
                    assets.random_cheer()
                    game.puck.holder = nil
                }
                collision.solve' in_col
            } else {
                if col.depth <= 0.0 {
                    ret
                }
                collision.solve' col
            }
        }
        a_i += 1
    }

    game.bodies -> for_each' fn c: collision.Body {
        c.pos += c.vel * delta
    }
    game.arena.update' delta
}

menu_state :: State {
    name: "menu",
    update: fn delta: float -> void {
        main_menu.update' delta
        if main_menu.line_selected {
            if main_menu_lines[main_menu.line_index] == "Connect" {
                // When we break out of the client loop, return here.
                states -> push' browser_state
            } else if main_menu_lines[main_menu.line_index] == "Practice" {
                states -> push' practice.new_practice_state'
            } else if main_menu_lines[main_menu.line_index] == "Start Server" {
                states -> push' server.new_server_state'
            } else if main_menu_lines[main_menu.line_index] == "Settings" {
                states -> push' config.new_settings_state'
            } else if main_menu_lines[main_menu.line_index] == "Credits" {
                states -> push' credits.new_credits_state'
            } else if main_menu_lines[main_menu.line_index] == "Quit" {
                states -> pop'
            } else {
                print "Unhandled main menu item:"
                print main_menu_lines[main_menu.line_index]
            }
        }
    },
    draw: main_menu.draw,
    process_input: fn {
        main_menu.process_input' menu.from_input' poll_input'
    },
    cleanup: fn {},
}

browser_menu := menu.menu_new' [], "Join a Game"

browser_state :: State {
    name: "Server browser",
    update: fn delta: float -> void {
        browser_menu.lines = browser.servers -> map' fn server: browser.Server -> str {
            as_str(server.online) + ": " + server.name
        }
    },
    draw: fn -> void {
        browser_menu.draw'
    },
    process_input: fn {
        browser_menu.process_input' menu.from_input' poll_input'

        if browser_menu.line_selected && len(browser_menu.lines) > 0 {
            // Disconnect from the server browser
            n_rpc_disconnect'

            // Connect to the selected server
            ip := browser.servers[browser_menu.line_index].join_ip
            states -> push' client.new_client_state' ip
            //TODO(gu): show connection error in ui in some way
        }
    },
    cleanup: fn {},
}

update :: fn delta: float -> void {
    state := last(states)
    if :State is state {
        state : !State = state
        state.update' delta
    }

    // Logic for moving "out" of the program
    if l_input_pressed("quit") {
        states -> pop'
    }
}

set_entities :: fn incoming_entities: [entity.Entity], incoming_players: {int: entity.Player}, incomming_arena: arena_mod.Arena, incoming_score: (int, int) {
    state := last(states)
    if :GameState is state {
        state : !GameState = state
        game := state.game

        game.entities = incoming_entities
        game.players = incoming_players
        game.arena = incomming_arena
        game.score = incoming_score
    }
}

move_camera :: fn game: Game {
    x :: -game.players[game.player_id].pos[0]
    curr_x :: l_gfx_camera_at()[0]
    speed :: min' 1.0, 4.0 * l_delta'
    x :: x * speed + curr_x * (1.0 - speed)
    l_gfx_camera_place' x, 0.0
    l_gfx_camera_set_zoom' 0.7
}

reset_camera :: fn {
    l_gfx_camera_place' 0.0, 0.0
    l_gfx_camera_set_zoom' 1.0
}

draw :: fn {
    state := last(states)
    if :State is state {
        state : !State = state
        state.draw'
    }
}

process_input :: fn {
    state := last(states)
    if :State is state {
        state : !State = state
        state.process_input'
    }
}

start :: fn {
    if "browser" in args() {
        browser.start'
    } else {
        // We set window size before ANY call to the engine so we have the correct size from the beginning
        l_set_window_size' (800, 800)
        init'
        l_audio_play' assets.crowd, true, 0.1, 1.0

        n_rpc_connect' config.BROWSER_SERVER_IP, config.BROWSER_SERVER_PORT

        // Added for safety - to avoid delta=0
        l_update'

        bind_keys'
        loop len(states) > 0 {
            n_rpc_resolve'

            l_update'
            l_render'

            update' l_delta'
            draw'
            process_input'
        }
    }
}
