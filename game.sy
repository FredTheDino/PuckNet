use arena_mod
use assets
use client
use collision
use entity
use menu
use mupps
use particles
use server
use tick
use util

players : [entity.Player] = []
entities : [entity.Entity] = []

puck : entity.Puck = entity.puck_new' (0.0, 0.0)
bodies : [collision.CircleBody] = []
arena: arena_mod.Arena = arena_mod.arena_new' (0.0, 0.0)

main_menu_lines := [
    "Connect",
    "Practice",
    "Start server",
    "Settings",
    "Credits",
    "Quit",
]
main_menu : menu.Menu = menu.menu_new' main_menu_lines
show_main_menu := true

exit := false

bind_keys :: fn {
    l_bind_key("w", "up")
    l_bind_key("a", "left")
    l_bind_key("s", "down")
    l_bind_key("d", "right")
    l_bind_key("q", "swap_player")
    l_bind_key("SPACE", "shoot")

    l_bind_axis(0, "LEFTX", "right")
    l_bind_axis(0, "LEFTY", "down")
    l_bind_button(0, "Y", "swap_player")
    l_bind_button(0, "A", "shoot")

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")
}

init :: fn {
    mupps.init'
    particles.init'
    assets.load_assets'
}

reset_state :: fn {
    puck.pos = (0.0, 0.0)
    players = []
    entities = [puck]
    bodies = [puck]
    num_players = 0
    player_id = -1
}

num_players := 0
player_join :: fn {
    // TODO(ed): This is a bad idea - since we can
    // have a race condition here.
    // We probably want to respond to ONLY that client.
    n_rpc_clients' assign_player_id, num_players

    [0, 1] -> for_each' fn id:int {
        player := entity.player_new' (l_random_range(-0.5, 0.5), l_random_range(-0.5, 0.5)), id, id, num_players
        push' players, player
        push' entities, player
        push' bodies, player
    }
    num_players += 1
}

assign_player_id :: fn id:int {
    if player_id == -1 {
        player_id = id
    }
}

servers: {str} = {}
broadcast_server :: fn ip:str {
    add' servers, ip
    n_rpc_clients' set_servers, servers
}

set_servers :: fn incoming_servers:{str} {
    servers = incoming_servers
    print servers
}

current_player := 0
player_id := -1
poll_input :: fn -> entity.Input {
    if l_input_pressed("swap_player") {
        current_player += 1
        current_player = rem' current_player, 2
    }

    entity.Input {
        dir: normalize((l_input_value("right") - l_input_value("left"),
                        l_input_value("up")    - l_input_value("down"))),

        tackle: l_input_pressed("shoot"),
        charge: l_input_down("shoot"),
        shoot: l_input_released("shoot"),

        player: 2 * player_id + current_player,
        select: l_input_pressed("shoot")
    }
}

set_input :: fn input: entity.Input {
    if players[input.player].input is nil {
        players[input.player].input = input
    } else {
        player_input: !entity.Input = players[input.player].input
        players[input.player].input = merge_inputs(player_input, input)
    }
}

merge_inputs :: fn current: entity.Input, new: entity.Input -> entity.Input {
    if current.player != new.player {
        ret new
    } else {
        ret entity.Input {
            dir: new.dir,
            charge: current.charge || new.charge,
            tackle: current.tackle || new.tackle,
            shoot: current.shoot || new.shoot,
            player: new.player,
            select: current.select || new.select,
        }
    }
}

clear_input :: fn input: entity.Input -> entity.Input {
    entity.Input {
        dir: input.dir,
        charge: false,
        tackle: false,
        shoot: false,
        player: input.player,
        select: false,
    }
}

process_player_input :: fn delta: float {
    players -> for_each' fn p: entity.Player {
        p.process_input' delta
        if p.input is :entity.Input {
            input: !entity.Input = p.input
            p.input = clear_input(input)
        }
    }
}

collision_check :: fn delta:float {
    iter := 1000
    t := 1.0
    loop t > 0.0 && iter > 0 {
        iter -= 1
        is_collision := false
        next_col := collision.Manifold {
            t: 2.0,
            normal: (0.0, 0.0),
            a: collision.Wall {
                pos: (0.0, 0.0),
                normal: (0.0, 0.0),
            },
            b: collision.Wall {
                pos: (0.0, 0.0),
                normal: (0.0, 0.0),
            },
        }

        // Find next collision
        a_i := 0
        // TODO(ed): Write this with for_each, when the upvalue bug is fixed.
        loop a_i < len(bodies) {
            a := bodies[a_i]
            b_i := -1
            bodies -> for_each' fn b: collision.CircleBody {
                b_i += 1
                // Skip the ones we've seen
                if a_i >= b_i {
                    ret
                }
                if :entity.Puck is a || :entity.Puck is b {
                    ret
                }
                col :: collision.circle_vs_circle' a, b, delta * t * (a.vel - b.vel)
                // TODO(ed): Don't capture other bodies.
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                next_col = col
                is_collision = true
            }
            arena.walls -> for_each' fn w: collision.Wall {
                col :: collision.circle_vs_wall' a, w, delta * t * a.vel
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                next_col = col
                is_collision = true
            }
            arena.corners -> for_each' fn c: collision.Circle {
                col :: collision.circle_vs_circle' a, c, delta * t * a.vel
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                if (sign(col.normal[1]) == sign(c.pos[1])
                    || sign(col.normal[0]) == sign(c.pos[0])
                    || magnitude_squared(a.pos) < magnitude_squared(c.pos)) {
                    ret
                }
                next_col = col
                is_collision = true
            }
            // Goal outside collision
            arena.goals -> for_each' fn g: arena_mod.Goal {
                col :: collision.circle_vs_circle' a, g.cage, delta * t * (a.vel - g.cage.vel)
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                if abs(a.pos[0]) > abs(g.cage.pos[0]) || sign(col.normal[0]) == sign(g.cage.pos[0]) {
                    ret
                }
                next_col = col
                is_collision = true
            }
            // Goal inside collision
            arena.goals -> for_each' fn g: arena_mod.Goal {
                // :(
                a.rad = -a.rad
                col :: collision.circle_vs_circle' a, g.cage, delta * t * (a.vel - g.cage.vel)
                a.rad = -a.rad
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                if abs(a.pos[0]) > abs(g.cage.pos[0]) || sign(col.normal[0]) != sign(g.cage.pos[0]) {
                    ret
                }
                next_col = col
                is_collision = true
            }
            a_i += 1
        }
        // Find next collision
        a_i := 0
        // TODO(ed): Write this with for_each, when the upvalue bug is fixed.
        loop a_i < len(bodies) {
            a := bodies[a_i]
            b_i := -1
            // TODO(ed): For 100% accuracy - this needs to move out
            // of the loop, and be checked afterwards.
            if :entity.Puck is a {
                arena.goals -> for_each' fn g: collision.Circle {
                    col :: collision.circle_vs_circle' a, g, delta * t * a.vel
                    if 0.0 <= col.t && col.t < t {

                        particles.goal' g.pos
                        n_rpc_clients' particles.goal, g.pos
                        puck.vel *= 0.0
                        puck.pos *= 0.0
                        if :entity.Player is puck.holder {
                            holder: !entity.Player = puck.holder
                            holder.puck = nil
                        }
                        puck.holder = nil
                    }
                }
            }
            a_i += 1
        }

        // Step up to the next collision
        step := min' t, next_col.t
        bodies -> for_each' fn c: collision.Body {
            c.pos += c.vel * step * delta
        }
        arena.update' step * delta

        true <=> :collision.Body is :entity.Player

        // Solve the collision
        if is_collision {
            // Elastic collision
            energy_kept :: 0.9
            n :: next_col.normal

            a :!collision.CircleBody = next_col.a
            if !:collision.CircleBody is a {
                a = collision.CircleBody{
                    mass: 0.0,
                    rad: 0.0,
                    pos: a.pos,
                    vel: (0.0, 0.0),
                }
            }
            b :!collision.CircleBody = next_col.b
            if !:collision.CircleBody is b {
                b = collision.CircleBody{
                    mass: 0.0,
                    rad: 0.0,
                    pos: b.pos,
                    vel: (0.0, 0.0),
                }
            }

            if :entity.Player is a && :entity.Player is b {
                a :!entity.Player : a
                b :!entity.Player : b
                if :entity.Puck is a.puck && magnitude_squared(a.vel) < magnitude_squared(b.vel) {
                    b.puck = a.puck
                    puck: !entity.Puck = b.puck
                    puck.holder = b
                    a.puck = nil
                }
                if :entity.Puck is b.puck && magnitude_squared(a.vel) > magnitude_squared(b.vel) {
                    a.puck = b.puck
                    puck: !entity.Puck = a.puck
                    puck.holder = a
                    b.puck = nil
                }
            }

            relative_v :: (1.0 + energy_kept) * (dot(a.vel, n) - dot(b.vel, n))
            tot_mass :: (a.mass + b.mass)

            skin :: 0.001
            if a.mass != 0. {
                a.pos += n * skin
                a.vel += n * -relative_v * a.mass / tot_mass
            }
            if b.mass != 0. {
                b.pos -= n * skin
                b.vel += n * relative_v * b.mass / tot_mass
            }
        }
        t -= step
    }
    if iter == 0 { <!> }
}

update :: fn delta: float -> void {
    if show_main_menu {
        main_menu.update' delta
        if main_menu.line_selected {
            if main_menu_lines[main_menu.line_index] == "Connect" {
                // When we break out of the client loop, return here.
                reset_state'
                if client.connect("127.0.0.1") {
                    show_main_menu = false
                    client.main_loop'
                    show_main_menu = true
                    main_menu.line_index = 0
                }
                //TODO(gu): else show connection error in ui in some way
            } else if main_menu_lines[main_menu.line_index] == "Start server" {
                reset_state'
                show_main_menu = false
                server.main_loop'
                show_main_menu = true
                main_menu.line_index = 0
            } else if main_menu_lines[main_menu.line_index] == "Practice" {
                reset_state'
                show_main_menu = false
            } else if main_menu_lines[main_menu.line_index] == "Quit" {
                exit = true
            } else {
                print "Unhandled main menu item:"
                print main_menu_lines[main_menu.line_index]
                exit = true
            }
        }
    } else {
        players -> for_each' fn p: entity.Player {
            p.try_grab' puck
        }

        collision_check' delta

        entities -> for_each' fn e: entity.Entity {
            e.update' delta
        }

        particles.update' delta
    }
}

set_entities :: fn incoming_entities: [entity.Entity], incoming_players: [entity.Player], incomming_arena: arena_mod.Arena {
    entities = incoming_entities
    players = incoming_players
    arena = incomming_arena
}

move_camera :: fn {
    if player_id != -1 {
        a :: 2 * player_id + current_player
        b :: 2 * player_id + rem' current_player + 1, 2
        delta_x :: abs' players[a].pos[0] - players[b].pos[0]
        weight :: min' 1.0, 0.4 + delta_x * 0.5
        x :: -(players[a].pos[0] * weight + players[b].pos[0] * (1.0 - weight))
        curr_x :: l_gfx_camera_at()[0]

        speed :: min' 1.0, 4.0 * l_delta'
        x :: x * speed + curr_x * (1.0 - speed)
        l_gfx_camera_place' x, 0.0
        l_gfx_camera_set_zoom' 0.7
    }
}

draw :: fn {
    if show_main_menu {
        main_menu.draw'
    } else {
        move_camera'

        arena.draw'
        particles.render'

        entities -> for_each' fn e: entity.Entity {
            if !(e is :entity.Puck) {
                e.draw'
            }
        }

        entities -> for_each' fn e: entity.Entity {
            if e is :entity.Puck {
                p: !entity.Puck = e
                // The holder will draw the puck in the right place if there is one
                if p.holder is :void {
                    e.draw'
                }
            }
        }

        mupps.draw'
    }
}

start :: fn {
    init'

    // Added for safety - to avoid delta=0
    l_update'

    l_set_window_size' (800, 800) //TODO(gu): set on startup so the window doesn't change size during start

    [0, 1] -> for_each' fn id:int {
        player := entity.player_new' (l_random_range(-0.5, 0.5), l_random_range(-0.5, 0.5)), id, id, 0
        push' players, player
        push' entities, player
        push' bodies, player
    }
    num_players += 1
    player_id = 0

    bind_keys'
    loop !l_input_down("quit") && !exit {
        l_update'
        l_render'

        if show_main_menu {
            main_menu.process_input' menu.from_input' poll_input'
        } else {
            set_input' poll_input'
            process_player_input' l_delta'
        }

        update' l_delta'
        draw'
    }
}
