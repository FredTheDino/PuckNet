use arena_mod
use assets
use collision

pi :: 3.14159265358979

clamp :: fn v: float, lo: float, hi: float -> float {
    min' hi, max' lo, v
}

dir :: fn rot: float -> (float, float) {
    (cos(rot), sin(rot))
}

angle_distance :: fn a: float, b: float -> float {
    angle' dir' b - a
}

friction :: fn v: (float, float), f: float -> (float, float) {
    if magnitude(v) <= f {
        ret (0.0, 0.0)
    } else {
        ret v - normalize(v) * f
    }
}

Entity :: blob {
    draw: fn -> void,
    update: fn float -> void,
}

Input :: blob {
    dir: (float, float),
    brake: bool,
    tackle: bool,
    shoot: bool,
    player: int,
}

Player :: blob {
    mass: float,
    rad: float,
    pos: (float, float),
    vel: (float, float),
    rot: float,
    acc: float,
    puck: Puck?,
    try_grab: fn Puck -> void,
    tackle_timer: float,
    draw: fn -> void,
    process_input: fn Input, float -> void,
    update: fn float -> void,
}

player_new :: fn pos: (float, float), team: int -> Player {

    sprites :: assets.player1 if team == 0 else assets.player2

    self: !Player = nil
    self = Player {
        mass: 100.0,
        rad: 0.05,
        pos: pos,
        rot: 0.0,
        vel: (0.0, 0.0),
        acc: 0.0,
        puck: nil,
        try_grab: fn puck: Puck -> void {
            if (magnitude(self.pos - puck.pos) < 0.05
                && puck.holder is nil
                && puck.hold_cooldown == 0.0) {
                self.puck = puck
                puck.holder = self
            }
        },
        tackle_timer: 0.0,
        draw: fn -> void {
            segment :: ((1 if self.rot > 1./4. * pi else 0) +
                        (1 if self.rot > 3./4. * pi else 0) +
                        (1 if self.rot > 5./4. * pi else 0) -
                        (3 if self.rot > 7./4. * pi else 0))
            sprite :: sprites[segment]
            widths :: [-12.0, 13.0, 12.0, 13.0]
            width :: widths[segment]
            height :: 15.
            scale :: 3.
            offset :: (0., self.rad)
            // Hitbox
            // l_gfx_rect' self.pos, (self.rad, self.rad) * 2., self.rot, (0., 0., 0.)
            l_gfx_sprite' sprite, (0, 0), self.pos + offset, (width, height) / height * self.rad * scale
        },
        process_input: fn input: Input, delta: float -> void {
            if input.shoot && self.puck is :Puck {
                shoot_speed :: 2.0 + magnitude' self.vel

                puck: !Puck = self.puck
                puck.vel = dir(self.rot) * shoot_speed
                puck.hold_cooldown = 0.1
                puck.holder = nil
                self.puck = nil
            }

            if self.tackle_timer == 0.0 && input.tackle && self.puck is nil {
                self.tackle_timer = 1.0
                self.vel += dir(self.rot) * 2.0
            }

            if self.tackle_timer > 0.5 {
                input.dir = (0.0, 0.0)
            }

            force :: 3.0
            self.acc += force * magnitude' input.dir

            break_fric :: 5.0
            if input.brake {
                self.vel = friction' self.vel, break_fric * delta
            }

            // Rotation
            max_rotation :: 4.0 + 6.0 / (2.0 * magnitude(input.dir) + 0.1) // rad/sec
            rotation_speed :: 2.0 * 3.14

            direction_angle :: angle(input.dir) if input.dir != (0.0, 0.0) else self.rot
            delta_angle :: angle_distance' self.rot, direction_angle
            rotation :: clamp' delta_angle * rotation_speed, -max_rotation, max_rotation
            self.rot += rotation * delta
            self.rot = rem' self.rot, 2. * pi
        },
        update: fn delta: float -> void {
            self.tackle_timer = max' 0.0, self.tackle_timer - delta

            // Linear motion
            self.vel += dir(self.rot) * self.acc * delta
            self.acc = 0.0

            // Air resistance
            air_fric :: 0.20 - self.tackle_timer * 0.1
            self.vel *= pow' air_fric, delta

            // Friction
            ice_fric :: 0.8
            self.vel = friction' self.vel, ice_fric * delta

            // Puck
            if self.puck is :Puck {
                puck: !Puck = self.puck
                puck.pos = self.pos
                // Without velocity the collisions won't work...
                puck.vel = self.vel
            }
        }
    }
    ret self
}

:Player is :Entity
:Player is :collision.Circle
:Player is :collision.Body
:Player is :collision.CircleBody

Puck :: blob {
    mass: float,
    rad: float,
    pos: (float, float),
    vel: (float, float),
    holder: Player?,
    hold_cooldown: float,
    draw: fn -> void,
    update: fn float -> void,
}

// we might need to tweek mass numbers
puck_new :: fn pos: (float, float) -> Puck {
    circle_rad :: 0.02
    self: !Puck = nil
    self = Puck{
        mass: 0.5,
        rad: sqrt(circle_rad * circle_rad * 2.0),
        pos: pos,
        vel: (0.0, 0.0),
        holder: nil,
        hold_cooldown: 0.0,
        draw: fn -> void {
            rgb :: (0.0, 0.0, 0.0)
            rad :: (circle_rad, circle_rad) * 2.0
            l_gfx_rect' self.pos, rad, 0.0, rgb
            l_gfx_rect' self.pos, rad, 3.14 * 1.0 / 5.0, rgb
            l_gfx_rect' self.pos, rad, 3.14 * 2.0 / 5.0, rgb
            l_gfx_rect' self.pos, rad, 3.14 * 3.0 / 5.0, rgb
            l_gfx_rect' self.pos, rad, 3.14 * 4.0 / 5.0, rgb
        },
        update: fn delta: float -> void {
            // Pickup cooldown
            self.hold_cooldown = max' self.hold_cooldown - delta, 0.0

            // Friction
            ice_fric :: 1.0
            speed :: magnitude' self.vel
            self.vel = friction' self.vel, ice_fric * delta
        }
    }
    ret self
}

:Puck is :Entity
:Puck is :collision.Circle
:Puck is :collision.Body
:Puck is :collision.CircleBody

// TODO(ed): Make this into a {int:[Player]} - so we
// can drop connections smoothly? Or no?
players : [Player] = []
entities : [Entity] = []

puck : Puck = puck_new' (0.0, 0.0)
bodies : [collision.CircleBody] = []
arena: arena_mod.Arena = arena_mod.arena_new' (0.0, 0.0)

goal_parts :: l_gfx_particle_new'

bind_keys :: fn {
    l_bind_key("w", "up")
    l_bind_key("a", "left")
    l_bind_key("s", "down")
    l_bind_key("d", "right")
    l_bind_key("SPACE", "brake")
    l_bind_key("e", "tackle")
    l_bind_key("q", "swap_player")
    l_bind_key("f", "shoot")

    l_bind_axis(0, "LEFTX", "right")
    l_bind_axis(0, "LEFTY", "down")
    l_bind_button(0, "A", "brake")
    l_bind_button(0, "B", "tackle")
    l_bind_button(0, "LEFTSHOULDER", "swap_player")
    l_bind_button(0, "RIGHTSHOULDER", "shoot")

    l_bind_quit("quit")
    l_bind_key("ESCAPE", "quit")
}

init :: fn {
    push' entities, puck
    push' bodies, puck

    d := 0.8

    l_gfx_particle_vel_angle' goal_parts, (0.0, 9.0)
    l_gfx_particle_vel_magnitude' goal_parts, (0.2, 0.3)
    l_gfx_particle_acc_magnitude' goal_parts, (0.0, 0.0)
    l_gfx_particle_drag' goal_parts, (0.9, 0.9)
    l_gfx_particle_start_sx(goal_parts, (0.02, 0.02))
    l_gfx_particle_start_sy(goal_parts, (0.02, 0.02))
    l_gfx_particle_end_sx(goal_parts, (0.02, 0.02))
    l_gfx_particle_end_sy(goal_parts, (0.02, 0.02))
}

num_players := 0
player_join :: fn {
    // TODO(ed): This is a bad idea - since we can
    // have a race condition here.
    // We probably want to respond to ONLY that client.
    n_rpc_clients' assign_player_id, num_players

    [0, 1] -> for_each' fn _:int {
        player := player_new' (l_random_range(-0.5, 0.5), l_random_range(-0.5, 0.5)), _
        push' players, player
        push' entities, player
        push' bodies, player
    }
    num_players += 1
}

assign_player_id :: fn id:int {
    if player_id == -1 {
        player_id = id
    }
}

current_player := 0
player_id := -1
poll_input :: fn -> Input {
    if l_input_pressed("swap_player") {
        current_player += 1
        current_player = rem' current_player, 2
    }

    if player_id != -1 {
        a :: player_id + current_player
        b :: player_id + rem' current_player + 1, 2
        delta_x :: abs' players[a].pos[0] - players[b].pos[0]
        weight :: min' 1.0, 0.4 + delta_x * 0.5
        x :: -(players[a].pos[0] * weight + players[b].pos[0] * (1.0 - weight))
        curr_x :: l_gfx_camera_at()[0]

        speed :: min' 1.0, 4.0 * l_delta'
        x :: x * speed + curr_x * (1.0 - speed)
        l_gfx_camera_place' x, 0.0
    }

    Input {
        // TODO: Normalize this
        dir: normalize((l_input_value("right") - l_input_value("left"),
                        l_input_value("up")    - l_input_value("down"))),

        brake: l_input_down("brake"),
        tackle: l_input_pressed("tackle"),
        shoot: l_input_pressed("shoot"),

        player: 2 * player_id + current_player,
    }
}

process_input :: fn input: Input {
    players[input.player].process_input' input, l_delta'
}

update :: fn delta: float -> void {
    players -> for_each' fn p: Player {
        p.try_grab' puck
    }

    iter := 1000
    t := 1.0
    loop t > 0.0 && iter > 0 {
        iter -= 1
        is_collision := false
        next_col := collision.Manifold {
            t: 2.0,
            normal: (0.0, 0.0),
            a: collision.Wall {
                pos: (0.0, 0.0),
                normal: (0.0, 0.0),
            },
            b: collision.Wall {
                pos: (0.0, 0.0),
                normal: (0.0, 0.0),
            },
        }

        // Find next collision
        a_i := 0
        // TODO(ed): Write this with for_each, when the upvalue bug is fixed.
        loop a_i < len(bodies) {
            a := bodies[a_i]
            b_i := -1
            bodies -> for_each' fn b: collision.CircleBody {
                b_i += 1
                // Skip the ones we've seen
                if a_i >= b_i {
                    ret
                }
                if a is :Puck || b is :Puck {
                    ret
                }
                col :: collision.circle_vs_circle' a, b, delta * t * (a.vel - b.vel)
                // TODO(ed): Don't capture other bodies.
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                next_col = col
                is_collision = true
            }
            arena.walls -> for_each' fn w: collision.Wall {
                col :: collision.circle_vs_wall' a, w, delta * t * a.vel
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                next_col = col
                is_collision = true
            }
            arena.corners -> for_each' fn c: collision.Circle {
                col :: collision.circle_vs_circle' a, c, delta * t * a.vel
                if col.t <= 0.0 || next_col.t < col.t {
                    ret
                }
                if (sign(col.normal[1]) == sign(c.pos[1])
                    || sign(col.normal[0]) == sign(c.pos[0])
                    || magnitude_squared(a.pos) < magnitude_squared(c.pos)) {
                    ret
                }
                next_col = col
                is_collision = true
            }

            // TODO(ed): For 100% accuracy - this needs to move out
            // of the loop, and be checked afterwards.
            if a is :Puck {
                arena.goals -> for_each' fn g: collision.Circle {
                    col :: collision.circle_vs_circle' a, g, delta * t * a.vel
                    if 0.0 <= col.t && col.t < t {

                        l_gfx_particle_vel_magnitude' goal_parts, (0.2, 1.2)
                        l_gfx_particle_x(goal_parts, (g.pos[0], g.pos[0]))
                        l_gfx_particle_y(goal_parts, (g.pos[1], g.pos[1]))
                        l_gfx_particle_spawn(goal_parts, 400)
                        l_gfx_particle_vel_magnitude' goal_parts, (0.2, 0.3)

                        puck.vel *= 0.0
                        puck.pos *= 0.0
                        if :Player is puck.holder {
                            holder: !Player = puck.holder
                            holder.puck = nil
                        }
                        puck.holder = nil
                    }
                }
            }
            a_i += 1
        }

        // Step up to the next collision
        step := min' t, next_col.t
        bodies -> for_each' fn c: collision.Body {
            c.pos += c.vel * step * delta
        }

        true <=> :collision.Body is :Player

        // Solve the collision
        if is_collision {
            // Elastic collision
            energy_kept :: 0.9
            n :: next_col.normal

            a :!collision.CircleBody = next_col.a
            if !:collision.CircleBody is a {
                a = collision.CircleBody{
                    mass: 0.0,
                    rad: 0.0,
                    pos: a.pos,
                    vel: (0.0, 0.0),
                }
            }
            b :!collision.CircleBody = next_col.b
            if !:collision.CircleBody is b {
                b = collision.CircleBody{
                    mass: 0.0,
                    rad: 0.0,
                    pos: b.pos,
                    vel: (0.0, 0.0),
                }
            }

            if :Player is a && :Player is b {
                a :!Player : a
                b :!Player : b
                if :Puck is a.puck && magnitude_squared(a.vel) < magnitude_squared(b.vel) {
                    b.puck = a.puck
                    puck: !Puck = b.puck
                    puck.holder = b
                    a.puck = nil
                }
                if :Puck is b.puck && magnitude_squared(a.vel) > magnitude_squared(b.vel) {
                    a.puck = b.puck
                    puck: !Puck = a.puck
                    puck.holder = a
                    b.puck = nil
                }
            }

            relative_v :: (1.0 + energy_kept) * (dot(a.vel, n) - dot(b.vel, n))
            tot_mass :: (a.mass + b.mass)

            skin :: 0.001
            a.pos += n * skin
            a.vel += n * -relative_v * a.mass / tot_mass
            b.pos -= n * skin
            b.vel += n * relative_v * b.mass / tot_mass
        }
        t -= step
    }
    if iter == 0 { <!> }

    entities -> for_each' fn e: Entity {
        e.update' delta
    }
}

set_entities :: fn incoming_entities: [Entity], incoming_players: [Player] {
    entities = incoming_entities
    players = incoming_players
}

draw :: fn {
    arena.draw'
    entities -> for_each' fn e: Entity {
        e.draw'
    }
    entities -> for_each' fn e: Entity {
        if e is :Puck {
            e.draw'
        }
    }

    arena.goals -> for_each' fn g: collision.Circle {
        l_gfx_particle_x(goal_parts, (g.pos[0], g.pos[0]))
        l_gfx_particle_y(goal_parts, (g.pos[1], g.pos[1]))
        l_gfx_particle_spawn(goal_parts, 10)
    }
    l_gfx_particle_update' goal_parts, l_delta'
    l_gfx_particle_render' goal_parts
}

start :: fn {
    // Added for safety - to avoid delta=0
    l_update'

    l_set_window_size' (800, 800)

    [0, 1] -> for_each' fn _:int {
        player := player_new' (l_random_range(-0.5, 0.5), l_random_range(-0.5, 0.5)), _
        push' players, player
        push' entities, player
        push' bodies, player
    }
    num_players += 1
    player_id = 0

    bind_keys'
    init'
    loop !l_input_down("quit") {
        l_update'
        l_render'
        process_input' poll_input'
        update' l_delta'
        draw'
    }
}
